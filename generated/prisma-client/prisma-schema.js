module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBaddie {
  count: Int!
}

type AggregateHero {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type Baddie {
  id: ID!
  name: String!
  powerLvl: Int!
  nemesis: Hero
  HP: Int!
}

type BaddieConnection {
  pageInfo: PageInfo!
  edges: [BaddieEdge]!
  aggregate: AggregateBaddie!
}

input BaddieCreateInput {
  name: String!
  powerLvl: Int!
  nemesis: HeroCreateOneWithoutNemesisInput
  HP: Int!
}

input BaddieCreateOneWithoutNemesisInput {
  create: BaddieCreateWithoutNemesisInput
  connect: BaddieWhereUniqueInput
}

input BaddieCreateWithoutNemesisInput {
  name: String!
  powerLvl: Int!
  HP: Int!
}

type BaddieEdge {
  node: Baddie!
  cursor: String!
}

enum BaddieOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  powerLvl_ASC
  powerLvl_DESC
  HP_ASC
  HP_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BaddiePreviousValues {
  id: ID!
  name: String!
  powerLvl: Int!
  HP: Int!
}

type BaddieSubscriptionPayload {
  mutation: MutationType!
  node: Baddie
  updatedFields: [String!]
  previousValues: BaddiePreviousValues
}

input BaddieSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BaddieWhereInput
  AND: [BaddieSubscriptionWhereInput!]
  OR: [BaddieSubscriptionWhereInput!]
  NOT: [BaddieSubscriptionWhereInput!]
}

input BaddieUpdateInput {
  name: String
  powerLvl: Int
  nemesis: HeroUpdateOneWithoutNemesisInput
  HP: Int
}

input BaddieUpdateManyMutationInput {
  name: String
  powerLvl: Int
  HP: Int
}

input BaddieUpdateOneWithoutNemesisInput {
  create: BaddieCreateWithoutNemesisInput
  update: BaddieUpdateWithoutNemesisDataInput
  upsert: BaddieUpsertWithoutNemesisInput
  delete: Boolean
  disconnect: Boolean
  connect: BaddieWhereUniqueInput
}

input BaddieUpdateWithoutNemesisDataInput {
  name: String
  powerLvl: Int
  HP: Int
}

input BaddieUpsertWithoutNemesisInput {
  update: BaddieUpdateWithoutNemesisDataInput!
  create: BaddieCreateWithoutNemesisInput!
}

input BaddieWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  powerLvl: Int
  powerLvl_not: Int
  powerLvl_in: [Int!]
  powerLvl_not_in: [Int!]
  powerLvl_lt: Int
  powerLvl_lte: Int
  powerLvl_gt: Int
  powerLvl_gte: Int
  nemesis: HeroWhereInput
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  AND: [BaddieWhereInput!]
  OR: [BaddieWhereInput!]
  NOT: [BaddieWhereInput!]
}

input BaddieWhereUniqueInput {
  id: ID
  name: String
}

type BatchPayload {
  count: Long!
}

type Hero {
  id: ID!
  name: String!
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team!]
  powerLvl: Int!
  HP: Int!
  nemesis: Baddie
}

type HeroConnection {
  pageInfo: PageInfo!
  edges: [HeroEdge]!
  aggregate: AggregateHero!
}

input HeroCreateInput {
  name: String!
  teams: TeamCreateManyWithoutMembersInput
  powerLvl: Int!
  HP: Int!
  nemesis: BaddieCreateOneWithoutNemesisInput
}

input HeroCreateManyWithoutTeamsInput {
  create: [HeroCreateWithoutTeamsInput!]
  connect: [HeroWhereUniqueInput!]
}

input HeroCreateOneWithoutNemesisInput {
  create: HeroCreateWithoutNemesisInput
  connect: HeroWhereUniqueInput
}

input HeroCreateWithoutNemesisInput {
  name: String!
  teams: TeamCreateManyWithoutMembersInput
  powerLvl: Int!
  HP: Int!
}

input HeroCreateWithoutTeamsInput {
  name: String!
  powerLvl: Int!
  HP: Int!
  nemesis: BaddieCreateOneWithoutNemesisInput
}

type HeroEdge {
  node: Hero!
  cursor: String!
}

enum HeroOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  powerLvl_ASC
  powerLvl_DESC
  HP_ASC
  HP_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HeroPreviousValues {
  id: ID!
  name: String!
  powerLvl: Int!
  HP: Int!
}

input HeroScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  powerLvl: Int
  powerLvl_not: Int
  powerLvl_in: [Int!]
  powerLvl_not_in: [Int!]
  powerLvl_lt: Int
  powerLvl_lte: Int
  powerLvl_gt: Int
  powerLvl_gte: Int
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  AND: [HeroScalarWhereInput!]
  OR: [HeroScalarWhereInput!]
  NOT: [HeroScalarWhereInput!]
}

type HeroSubscriptionPayload {
  mutation: MutationType!
  node: Hero
  updatedFields: [String!]
  previousValues: HeroPreviousValues
}

input HeroSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HeroWhereInput
  AND: [HeroSubscriptionWhereInput!]
  OR: [HeroSubscriptionWhereInput!]
  NOT: [HeroSubscriptionWhereInput!]
}

input HeroUpdateInput {
  name: String
  teams: TeamUpdateManyWithoutMembersInput
  powerLvl: Int
  HP: Int
  nemesis: BaddieUpdateOneWithoutNemesisInput
}

input HeroUpdateManyDataInput {
  name: String
  powerLvl: Int
  HP: Int
}

input HeroUpdateManyMutationInput {
  name: String
  powerLvl: Int
  HP: Int
}

input HeroUpdateManyWithoutTeamsInput {
  create: [HeroCreateWithoutTeamsInput!]
  delete: [HeroWhereUniqueInput!]
  connect: [HeroWhereUniqueInput!]
  set: [HeroWhereUniqueInput!]
  disconnect: [HeroWhereUniqueInput!]
  update: [HeroUpdateWithWhereUniqueWithoutTeamsInput!]
  upsert: [HeroUpsertWithWhereUniqueWithoutTeamsInput!]
  deleteMany: [HeroScalarWhereInput!]
  updateMany: [HeroUpdateManyWithWhereNestedInput!]
}

input HeroUpdateManyWithWhereNestedInput {
  where: HeroScalarWhereInput!
  data: HeroUpdateManyDataInput!
}

input HeroUpdateOneWithoutNemesisInput {
  create: HeroCreateWithoutNemesisInput
  update: HeroUpdateWithoutNemesisDataInput
  upsert: HeroUpsertWithoutNemesisInput
  delete: Boolean
  disconnect: Boolean
  connect: HeroWhereUniqueInput
}

input HeroUpdateWithoutNemesisDataInput {
  name: String
  teams: TeamUpdateManyWithoutMembersInput
  powerLvl: Int
  HP: Int
}

input HeroUpdateWithoutTeamsDataInput {
  name: String
  powerLvl: Int
  HP: Int
  nemesis: BaddieUpdateOneWithoutNemesisInput
}

input HeroUpdateWithWhereUniqueWithoutTeamsInput {
  where: HeroWhereUniqueInput!
  data: HeroUpdateWithoutTeamsDataInput!
}

input HeroUpsertWithoutNemesisInput {
  update: HeroUpdateWithoutNemesisDataInput!
  create: HeroCreateWithoutNemesisInput!
}

input HeroUpsertWithWhereUniqueWithoutTeamsInput {
  where: HeroWhereUniqueInput!
  update: HeroUpdateWithoutTeamsDataInput!
  create: HeroCreateWithoutTeamsInput!
}

input HeroWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  teams_every: TeamWhereInput
  teams_some: TeamWhereInput
  teams_none: TeamWhereInput
  powerLvl: Int
  powerLvl_not: Int
  powerLvl_in: [Int!]
  powerLvl_not_in: [Int!]
  powerLvl_lt: Int
  powerLvl_lte: Int
  powerLvl_gt: Int
  powerLvl_gte: Int
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  nemesis: BaddieWhereInput
  AND: [HeroWhereInput!]
  OR: [HeroWhereInput!]
  NOT: [HeroWhereInput!]
}

input HeroWhereUniqueInput {
  id: ID
  name: String
}

scalar Long

type Mutation {
  createBaddie(data: BaddieCreateInput!): Baddie!
  updateBaddie(data: BaddieUpdateInput!, where: BaddieWhereUniqueInput!): Baddie
  updateManyBaddies(data: BaddieUpdateManyMutationInput!, where: BaddieWhereInput): BatchPayload!
  upsertBaddie(where: BaddieWhereUniqueInput!, create: BaddieCreateInput!, update: BaddieUpdateInput!): Baddie!
  deleteBaddie(where: BaddieWhereUniqueInput!): Baddie
  deleteManyBaddies(where: BaddieWhereInput): BatchPayload!
  createHero(data: HeroCreateInput!): Hero!
  updateHero(data: HeroUpdateInput!, where: HeroWhereUniqueInput!): Hero
  updateManyHeroes(data: HeroUpdateManyMutationInput!, where: HeroWhereInput): BatchPayload!
  upsertHero(where: HeroWhereUniqueInput!, create: HeroCreateInput!, update: HeroUpdateInput!): Hero!
  deleteHero(where: HeroWhereUniqueInput!): Hero
  deleteManyHeroes(where: HeroWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  baddie(where: BaddieWhereUniqueInput!): Baddie
  baddies(where: BaddieWhereInput, orderBy: BaddieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Baddie]!
  baddiesConnection(where: BaddieWhereInput, orderBy: BaddieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BaddieConnection!
  hero(where: HeroWhereUniqueInput!): Hero
  heroes(where: HeroWhereInput, orderBy: HeroOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hero]!
  heroesConnection(where: HeroWhereInput, orderBy: HeroOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HeroConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  node(id: ID!): Node
}

type Subscription {
  baddie(where: BaddieSubscriptionWhereInput): BaddieSubscriptionPayload
  hero(where: HeroSubscriptionWhereInput): HeroSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
}

type Team {
  id: ID!
  name: String!
  members(where: HeroWhereInput, orderBy: HeroOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hero!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  name: String!
  members: HeroCreateManyWithoutTeamsInput
}

input TeamCreateManyWithoutMembersInput {
  create: [TeamCreateWithoutMembersInput!]
  connect: [TeamWhereUniqueInput!]
}

input TeamCreateWithoutMembersInput {
  name: String!
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPreviousValues {
  id: ID!
  name: String!
}

input TeamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [TeamScalarWhereInput!]
  OR: [TeamScalarWhereInput!]
  NOT: [TeamScalarWhereInput!]
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  name: String
  members: HeroUpdateManyWithoutTeamsInput
}

input TeamUpdateManyDataInput {
  name: String
}

input TeamUpdateManyMutationInput {
  name: String
}

input TeamUpdateManyWithoutMembersInput {
  create: [TeamCreateWithoutMembersInput!]
  delete: [TeamWhereUniqueInput!]
  connect: [TeamWhereUniqueInput!]
  set: [TeamWhereUniqueInput!]
  disconnect: [TeamWhereUniqueInput!]
  update: [TeamUpdateWithWhereUniqueWithoutMembersInput!]
  upsert: [TeamUpsertWithWhereUniqueWithoutMembersInput!]
  deleteMany: [TeamScalarWhereInput!]
  updateMany: [TeamUpdateManyWithWhereNestedInput!]
}

input TeamUpdateManyWithWhereNestedInput {
  where: TeamScalarWhereInput!
  data: TeamUpdateManyDataInput!
}

input TeamUpdateWithoutMembersDataInput {
  name: String
}

input TeamUpdateWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutMembersDataInput!
}

input TeamUpsertWithWhereUniqueWithoutMembersInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutMembersDataInput!
  create: TeamCreateWithoutMembersInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  members_every: HeroWhereInput
  members_some: HeroWhereInput
  members_none: HeroWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
  name: String
}
`
      }
    